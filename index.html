<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bbootage</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; font-family: Arial; color: white; }
        canvas { display: block; margin: auto; }
        #menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        button { padding: 10px; margin: 5px; font-size: 20px; background: #333; color: white; border: 1px solid white; }
        #score { position: absolute; top: 10px; left: 10px; font-size: 24px; }
        #actionBtn { position: absolute; bottom: 20px; right: 20px; width: 80px; height: 80px; background: red; border-radius: 50%; display: none; font-size: 20px; color: white; border: none; }
        #credits { font-size: 12px; margin-top: 20px; }
        #pauseScreen { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; font-size: 40px; display: none; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="menu">
        <h1>Bbootage</h1>
        <button onclick="startGame('Normal')">Normal Mode</button>
        <button onclick="startGame('Psy')">Psy Mode</button>
        <button onclick="startGame('Ika')">Ika Mode</button>
        <button onclick="startGame('GW')">GW Mode</button>
        <button onclick="startGame('Infinite')">Infinite Mode</button>
        <p id="credits">Inspirado em rRootage, feito s? por Marko o rei!</p>
    </div>
    <div id="score">Score: 0</div>
    <button id="actionBtn" ontouchstart="actionPress()" ontouchend="actionRelease()">Action</button>
    <div id="pauseScreen">Score: 0<br>Move to Continue</div>
    <audio id="bgm" loop src="https://orangefreesounds.com/wp-content/uploads/2025/04/8-bit-chiptune-music.mp3"></audio>
    <audio id="laser" src="https://www.zapsplat.com/wp-content/uploads/2015/sound-effects-8-bit/8bit_laser_001.mp3"></audio>
    <audio id="explosion" src="https://www.zapsplat.com/wp-content/uploads/2015/sound-effects-8-bit/8bit_explosion_001.mp3"></audio>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const menu = document.getElementById('menu');
        const scoreDiv = document.getElementById('score');
        const actionBtn = document.getElementById('actionBtn');
        const pauseScreen = document.getElementById('pauseScreen');
        const bgm = document.getElementById('bgm');
        const laserSound = document.getElementById('laser');
        const explosionSound = document.getElementById('explosion');
        let width, height;
        let player = { x: 0, y: 0, size: 10, color: 'white', speed: 5, firing: false, polarity: 'white', action: false, grazeMeter: 0, reflectMeter: 100, moved: false };
        let bullets = [];
        let enemyBullets = [];
        let particles = [];
        let boss = { x: 0, y: 0, hp: 1000, maxHp: 1000, shape: [], attacks: [], phase: 1, scale: 1, attackFreq: 0.05 };
        let currentMode = '';
        let phase = 1;
        let score = 0;
        let infinite = false;
        let keys = {};
        let touchX = 0, touchY = 0, touching = false;
        let isMobile = /Mobi|Android/i.test(navigator.userAgent);
        let shake = 0;
        let flash = 0;
        let paused = false;
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            player.x = width / 2;
            player.y = height - 50;
            boss.x = width / 2;
            boss.y = 100;
        }
        resize();
        window.addEventListener('resize', resize);
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);
        canvas.addEventListener('touchstart', e => { touching = true; touchX = e.touches[0].clientX; touchY = e.touches[0].clientY; });
        canvas.addEventListener('touchmove', e => { touchX = e.touches[0].clientX; touchY = e.touches[0].clientY; });
        canvas.addEventListener('touchend', () => touching = false);
        function startGame(mode) {
            currentMode = mode;
            infinite = mode === 'Infinite';
            menu.style.display = 'none';
            scoreDiv.style.display = 'block';
            if (isMobile) actionBtn.style.display = 'block';
            phase = 1;
            score = 0;
            player.grazeMeter = 0;
            player.reflectMeter = 100;
            player.polarity = 'white';
            generateBoss();
            bgm.play();
            gameLoop();
        }
        function generateBoss() {
            boss.hp = 1000 + (phase - 1) * 500;
            boss.maxHp = boss.hp;
            boss.scale = 1;
            boss.phase = 1;
            boss.attackFreq = 0.05 + (phase - 1) * 0.005;
            boss.shape = generateRandomShape();
            boss.attacks = chooseAttacks();
            paused = false;
            player.moved = false;
        }
        function generateRandomShape() {
            let shapes = [];
            let numLayers = Math.floor(Math.random() * 3) + 2;
            for (let l = 0; l < numLayers; l++) {
                let type = Math.floor(Math.random() * 5);
                let size = 50 + l * 10;
                if (type === 0) {
                    shapes.push({ type: 'triangle', points: [{x:0,y:-size}, {x:-size,y:size}, {x:size,y:size}] });
                } else if (type === 1) {
                    shapes.push({ type: 'square', points: [{x:-size,y:-size}, {x:size,y:-size}, {x:size,y:size}, {x:-size,y:size}] });
                } else if (type === 2) {
                    shapes.push({ type: 'circle', radius: size });
                } else if (type === 3) {
                    shapes.push({ type: 'pentagon', points: Array.from({length: 5}, (_, i) => ({x: size * Math.cos(2 * Math.PI * i / 5), y: size * Math.sin(2 * Math.PI * i / 5)})) });
                } else {
                    shapes.push({ type: 'star', points: Array.from({length: 5}, (_, i) => {
                        let r = i % 2 === 0 ? size : size / 2;
                        return {x: r * Math.cos(2 * Math.PI * i / 5 - Math.PI / 2), y: r * Math.sin(2 * Math.PI * i / 5 - Math.PI / 2)};
                    })});
                }
            }
            return shapes;
        }
        function chooseAttacks() {
            let attacks = ['spiral', 'wave', 'laser', 'burst', 'homing', 'circleBurst', 'cross', 'randomSpray', 'vortex', 'beam', 'scatter', 'ring', 'zigzag'];
            let selected = [];
            for (let i = 0; i < 5; i++) {
                selected.push(attacks[Math.floor(Math.random() * attacks.length)]);
            }
            return selected;
        }
        function actionPress() {
            player.action = true;
        }
        function actionRelease() {
            player.action = false;
        }
        function updatePlayer() {
            let oldX = player.x;
            let oldY = player.y;
            if (keys['w'] || keys['W']) player.y -= player.speed;
            if (keys['a'] || keys['A']) player.x -= player.speed;
            if (keys['s'] || keys['S']) player.y += player.speed;
            if (keys['d'] || keys['D']) player.x += player.speed;
            if (keys[' '] || !isMobile) player.firing = true;
            else player.firing = false;
            if (touching) {
                player.x = touchX;
                player.y = touchY;
                player.firing = true;
            }
            player.x = Math.max(player.size, Math.min(width - player.size, player.x));
            player.y = Math.max(player.size, Math.min(height - player.size, player.y));
            if (paused && (player.x !== oldX || player.y !== oldY)) {
                player.moved = true;
            }
        }
        function firePlayer() {
            if (player.firing) {
                bullets.push({ x: player.x, y: player.y - player.size, vx: 0, vy: -10 - (phase * 0.2), color: 'blue', trail: [] });
                laserSound.play();
            }
        }
        function updateBullets() {
            bullets.forEach(b => {
                b.y += b.vy;
                b.trail.push({x: b.x, y: b.y});
                if (b.trail.length > 15) b.trail.shift();
                if (b.y < 0) bullets.splice(bullets.indexOf(b), 1);
            });
            enemyBullets.forEach(eb => {
                eb.x += eb.vx;
                eb.y += eb.vy;
                if (eb.type === 'homing') {
                    let dx = player.x - eb.x;
                    let dy = player.y - eb.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 0) {
                        eb.vx = (dx / dist) * (5 + phase * 0.5);
                        eb.vy = (dy / dist) * (5 + phase * 0.5);
                    }
                } else if (eb.type === 'zigzag') {
                    eb.vx = Math.sin(eb.y / 20) * 3;
                }
                eb.trail.push({x: eb.x, y: eb.y});
                if (eb.trail.length > 10) eb.trail.shift();
                if (eb.x < 0 || eb.x > width || eb.y < 0 || eb.y > height) enemyBullets.splice(enemyBullets.indexOf(eb), 1);
            });
        }
        function bossAI() {
            if (paused) return;
            if (boss.hp / boss.maxHp < 0.3) {
                boss.scale = 1.5;
                boss.phase = 2;
                if (Math.random() < 0.2) {
                    boss.attacks.forEach(attack => fireBossAttack(attack));
                }
            }
            let attack = boss.attacks[Math.floor(Math.random() * boss.attacks.length)];
            if (Math.random() < boss.attackFreq || boss.phase === 2 && Math.random() < 0.1) {
                fireBossAttack(attack);
            }
            boss.x += Math.sin(Date.now() / 1000) * (2 + phase * 0.1);
        }
        function fireBossAttack(type) {
            let count = boss.phase === 1 ? 10 : 20;
            let speed = boss.phase === 1 ? 3 + phase * 0.5 : 5 + phase * 0.5;
            let color = ['red', 'orange', 'yellow', 'green', 'blue', 'purple', 'pink', 'white'][Math.floor(Math.random() * 8)];
            if (type === 'spiral') {
                for (let i = 0; i < count; i++) {
                    let angle = (i / count) * Math.PI * 2 + Date.now() / 500;
                    enemyBullets.push({ x: boss.x, y: boss.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, color, trail: [], type: 'normal' });
                }
            } else if (type === 'wave') {
                for (let i = 0; i < count; i++) {
                    let angle = Math.PI + (i - count/2) * 0.1 + Math.sin(Date.now() / 1000) * 0.2;
                    enemyBullets.push({ x: boss.x, y: boss.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, color, trail: [], type: 'normal' });
                }
            } else if (type === 'laser') {
                for (let i = 0; i < 5; i++) {
                    let angle = Math.atan2(player.y - boss.y, player.x - boss.x) + (i-2)*0.1;
                    enemyBullets.push({ x: boss.x, y: boss.y, vx: Math.cos(angle) * speed * 1.5, vy: Math.sin(angle) * speed * 1.5, color, trail: [], type: 'normal' });
                }
            } else if (type === 'burst') {
                for (let i = 0; i < count * 2; i++) {
                    let angle = Math.random() * Math.PI * 2;
                    enemyBullets.push({ x: boss.x, y: boss.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, color, trail: [], type: 'normal' });
                }
            } else if (type === 'homing') {
                for (let i = 0; i < count; i++) {
                    enemyBullets.push({ x: boss.x, y: boss.y, vx: 0, vy: 0, color, trail: [], type: 'homing' });
                }
            } else if (type === 'circleBurst') {
                for (let i = 0; i < count * 1.5; i++) {
                    let angle = (i / count) * Math.PI * 2;
                    enemyBullets.push({ x: boss.x, y: boss.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, color, trail: [], type: 'normal' });
                }
            } else if (type === 'cross') {
                for (let i = 0; i < count; i++) {
                    let angle = Math.PI / 4 + i * Math.PI / 2 + Date.now() / 2000;
                    enemyBullets.push({ x: boss.x, y: boss.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, color, trail: [], type: 'normal' });
                }
            } else if (type === 'randomSpray') {
                for (let i = 0; i < count * 3; i++) {
                    let angle = Math.PI + Math.random() * Math.PI / 2 - Math.PI / 4;
                    enemyBullets.push({ x: boss.x, y: boss.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, color, trail: [], type: 'normal' });
                }
            } else if (type === 'vortex') {
                for (let i = 0; i < count; i++) {
                    let angle = (i / count) * Math.PI * 2 - Date.now() / 500;
                    enemyBullets.push({ x: boss.x, y: boss.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, color, trail: [], type: 'normal' });
                }
            } else if (type === 'beam') {
                for (let i = 0; i < 3; i++) {
                    let angle = Math.atan2(player.y - boss.y, player.x - boss.x) + (i-1)*0.3;
                    for (let j = 0; j < 5; j++) {
                        enemyBullets.push({ x: boss.x, y: boss.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, color, trail: [], type: 'normal' });
                    }
                }
            } else if (type === 'scatter') {
                for (let i = 0; i < count * 2; i++) {
                    let angle = Math.PI + Math.random() * Math.PI - Math.PI / 2;
                    enemyBullets.push({ x: boss.x, y: boss.y, vx: Math.cos(angle) * speed * Math.random(), vy: Math.sin(angle) * speed, color, trail: [], type: 'normal' });
                }
            } else if (type === 'ring') {
                for (let i = 0; i < count; i++) {
                    let angle = (i / count) * Math.PI * 2;
                    enemyBullets.push({ x: boss.x, y: boss.y, vx: Math.cos(angle) * speed / 2, vy: Math.sin(angle) * speed / 2, color, trail: [], type: 'normal' });
                }
            } else if (type === 'zigzag') {
                for (let i = 0; i < count; i++) {
                    let angle = Math.PI + (i - count/2) * 0.05;
                    enemyBullets.push({ x: boss.x, y: boss.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, color, trail: [], type: 'zigzag' });
                }
            }
        }
        function checkCollisions() {
            if (paused) return;
            bullets.forEach(b => {
                let dx = b.x - boss.x;
                let dy = b.y - boss.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 50 * boss.scale) {
                    boss.hp -= 10 + phase;
                    score += 100 + phase * 10;
                    bullets.splice(bullets.indexOf(b), 1);
                    createParticles(b.x, b.y, 'blue', 30);
                    shake = 5;
                    flash = 10;
                    explosionSound.play();
                    if (boss.hp <= 0) {
                        createParticles(boss.x, boss.y, 'red', 200);
                        shake = 20;
                        paused = true;
                        pauseScreen.innerText = `Score: ${score}\nMove to Continue`;
                        pauseScreen.style.display = 'block';
                    }
                }
            });
            enemyBullets.forEach(eb => {
                let dx = eb.x - player.x;
                let dy = eb.y - player.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < player.size + 5) {
                    if (handleModeCollision(eb)) {
                        enemyBullets.splice(enemyBullets.indexOf(eb), 1);
                        createParticles(eb.x, eb.y, eb.color, 20);
                    } else {
                        endGame();
                    }
                } else if (dist < player.size + 15) {
                    if (currentMode === 'Psy') player.grazeMeter = Math.min(100, player.grazeMeter + 2);
                    score += 20;
                    createParticles(eb.x, eb.y, 'white', 10);
                }
            });
        }
        function handleModeCollision(eb) {
            if (currentMode === 'Normal' && player.action) {
                enemyBullets = [];
                return true;
            } else if (currentMode === 'Psy' && player.grazeMeter >= 100) {
                player.grazeMeter = 0;
                return true;
            } else if (currentMode === 'Ika' && eb.color === player.polarity) {
                bullets.push({ x: eb.x, y: eb.y, vx: 0, vy: -10, color: 'blue', trail: [] });
                return true;
            } else if (currentMode === 'GW' && player.action && player.reflectMeter > 0) {
                eb.vx = -eb.vx;
                eb.vy = -eb.vy;
                player.reflectMeter -= 5;
                return true;
            }
            return false;
        }
        function updateModes() {
            if (paused) return;
            if (currentMode === 'Psy' && player.action) {
                player.grazeMeter += 1;
            }
            if (currentMode === 'Ika' && player.action) {
                player.polarity = player.polarity === 'white' ? 'black' : 'white';
            }
            if (currentMode === 'GW') {
                player.reflectMeter = Math.min(100, player.reflectMeter + 0.2);
            }
            if (infinite) {
                boss.hp += 0.2 + phase * 0.1;
            }
        }
        function createParticles(x, y, color, count = 20) {
            for (let i = 0; i < count; i++) {
                particles.push({ x, y, vx: Math.random() * 10 - 5, vy: Math.random() * 10 - 5, life: 60 + Math.random() * 40, color });
            }
        }
        function updateParticles() {
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if (p.life <= 0) particles.splice(particles.indexOf(p), 1);
            });
        }
        function draw() {
            ctx.clearRect(0, 0, width, height);
            if (shake > 0) {
                ctx.translate(Math.random() * shake - shake / 2, Math.random() * shake - shake / 2);
                shake--;
            }
            if (flash > 0) {
                ctx.filter = 'brightness(2)';
                flash--;
            } else {
                ctx.filter = 'none';
            }
            ctx.save();
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'white';
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
            ctx.fillStyle = player.polarity || 'white';
            ctx.fill();
            ctx.restore();
            boss.shape.forEach(s => {
                ctx.save();
                ctx.translate(boss.x, boss.y);
                ctx.scale(boss.scale, boss.scale);
                ctx.shadowBlur = 30;
                ctx.shadowColor = 'red';
                ctx.filter = 'brightness(1.2) blur(2px)';
                if (s.type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(0, 0, s.radius, 0, Math.PI * 2);
                    ctx.fillStyle = 'red';
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(s.points[0].x, s.points[0].y);
                    s.points.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.closePath();
                    ctx.fillStyle = 'red';
                    ctx.fill();
                }
                ctx.restore();
            });
            // Barra de vida em cima
            ctx.save();
            let hpPercent = boss.hp / boss.maxHp;
            ctx.fillStyle = `rgb(${255 * (1 - hpPercent)}, ${255 * hpPercent}, 0)`;
            ctx.fillRect(width / 4, 20, (width / 2) * hpPercent, 20);
            ctx.strokeStyle = 'white';
            ctx.strokeRect(width / 4, 20, width / 2, 20);
            ctx.restore();
            bullets.forEach(b => {
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = b.color;
                ctx.filter = 'blur(1px)';
                ctx.beginPath();
                ctx.moveTo(b.x, b.y);
                b.trail.forEach(t => ctx.lineTo(t.x, t.y));
                ctx.strokeStyle = b.color;
                ctx.stroke();
                ctx.restore();
            });
            enemyBullets.forEach(eb => {
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = eb.color;
                ctx.filter = 'brightness(1.5) blur(2px)';
                ctx.beginPath();
                ctx.arc(eb.x, eb.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = eb.color;
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(eb.x, eb.y);
                eb.trail.forEach(t => ctx.lineTo(t.x, t.y));
                ctx.strokeStyle = eb.color;
                ctx.stroke();
                ctx.restore();
            });
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life / 100;
                ctx.shadowBlur = 5;
                ctx.shadowColor = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();
                ctx.restore();
            });
            if (currentMode === 'Psy') {
                ctx.fillStyle = 'white';
                ctx.fillRect(10, height - 20, player.grazeMeter * 2, 10);
            } else if (currentMode === 'GW') {
                ctx.fillStyle = 'green';
                ctx.fillRect(10, height - 20, player.reflectMeter * 2, 10);
            }
            scoreDiv.innerText = `Score: ${score}`;
            ctx.filter = 'none';
        }
        function endGame() {
            menu.style.display = 'block';
            scoreDiv.style.display = 'none';
            actionBtn.style.display = 'none';
            pauseScreen.style.display = 'none';
            bgm.pause();
            bullets = [];
            enemyBullets = [];
            particles = [];
            paused = false;
        }
        function gameLoop() {
            updatePlayer();
            if (!paused) {
                firePlayer();
                updateBullets();
                bossAI();
                checkCollisions();
                updateModes();
            } else if (player.moved) {
                pauseScreen.style.display = 'none';
                phase++;
                if (phase > 40 && !infinite) endGame();
                else generateBoss();
            }
            updateParticles();
            draw();
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>